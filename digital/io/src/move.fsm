# Move FSM
# This FSM is responsible to move the bot from the current position to the
# desired one. It will try to avoid obstacle and manage the case when the
# asserv is blocked.
move
  move with avoid obstacle.

States:
 IDLE
  waiting for the beginning of the move FSM.
 MOVING
  moving to a position (intermediate or final).
 MOVING_BACKWARD_TO_TURN_FREELY
  moving backward to go away from what is blocking the bot.
 WAIT_FOR_CLEAR_PATH [timeout=255]
  waiting for obstacle to disappear.

Events:
 start
  initialize the FSM and start the movement directly.
 bot_move_failed
  the bot movement failed (blocked by something for example).
 bot_move_succeed
  the bot has finished to moved and arrived at the desired position.
 obstacle_in_front
  the bot has seen something (with the sharps) (front is the same when going backward).
 state_timeout
  timeout.

IDLE:
 start -> MOVING
  ask the asserv to go to the computed position.

MOVING:
 bot_move_succeed: we_are_at_final_position -> IDLE
  post an event for the top FSM to tell it we have finished.
 bot_move_succeed: position_intermediary -> .
  get next position computed by the path module.
  if next position is the final, use a goto_xya.
  otherwise go to the next intermediate position with goto.
 bot_move_succeed: no_intermediate_path_found -> IDLE
  post an event for the top FSM to generate a failure.
 bot_move_failed -> MOVING_BACKWARD_TO_TURN_FREELY
  compute the obstacle position.
  move backward to turn freely.
 obstacle_in_front -> WAIT_FOR_CLEAR_PATH
  stop the bot.

MOVING_BACKWARD_TO_TURN_FREELY:
 bot_move_succeed: intermediate_path_found -> MOVING
  get next intermediate position from path module.
 bot_move_succeed: no_intermediate_path_found -> IDLE
  post an event for the top FSM to generate a failure.
 bot_move_failed: intermediate_path_found -> MOVING
  get next intermediate position from path module
 bot_move_failed: no_intermediate_path_found -> WAIT_FOR_CLEAR_PATH
  nothing to do.

WAIT_FOR_CLEAR_PATH:
 state_timeout: no_more_obstacle_or_next_position -> MOVING
  get next position computed by the path module.
  if next position is the final, use a goto_xya.
  otherwise go to the next intermediate position with goto.
 state_timeout: obstacle_and_no_intermediate_path_found_and_try_again -> .
  decrement counter.
 state_timeout: obstacle_and_no_intermediate_path_found_and_no_try_again -> IDLE
  post an event for the top FSM to generate a failure.
